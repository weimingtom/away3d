package away3dlite.loaders{	import away3dlite.animators.MovieMesh;	import away3dlite.animators.MovieMeshContainer3D;	import away3dlite.arcane;	import away3dlite.core.IDestroyable;	import away3dlite.core.utils.Debug;	import away3dlite.events.ParserEvent;	import away3dlite.materials.BitmapFileMaterial;		import flash.utils.ByteArray;	import flash.utils.Dictionary;		import nochump.util.zip.ZipEntry;	import nochump.util.zip.ZipFile;

	use namespace arcane;	/**	 * File loader for the MDZ file format. (MD2, PNG, MD2, PNG,...) in zip format.	 * @author katopz@sleepydesign.com	 */	public class MDZ extends AbstractParser implements IDestroyable	{		private var _materials:Dictionary;		/** @private */		arcane override function prepareData(data:*):void		{			var i:int = 0;			var _zipFile:ZipFile = new ZipFile(data);			var _entry:ZipEntry;			var _fileType:String;			var _fileName:String;			_materials = new Dictionary(true);			// material			for (i = 0; i < _zipFile.entries.length; i++)			{				_entry = _zipFile.entries[i];				_fileType = _entry.name.slice(_entry.name.indexOf("."));				_fileName = _entry.name.split(_fileType)[0];								if (_fileType == ".png")				{					var _bmpByteArray:ByteArray = _zipFile.getInput(_entry);					_materials[_entry.name] = _bmpByteArray;					Debug.trace(" ! Unzip :" + _entry.name);				}			}			// mesh			for (i = 0; i < _zipFile.entries.length; i++)			{				_entry = _zipFile.entries[i];				_fileType = _entry.name.slice(_entry.name.indexOf("."));				_fileName = _entry.name.split(_fileType)[0];				if (_fileType == ".md2")				{					var _md2ByteArray:ByteArray = _zipFile.getInput(_entry);					var _md2:MD2 = new MD2();					_md2.scaling = scaling;					_md2.name = _fileName;					_md2.addOnSuccess(onSuccess);					_md2.material = new BitmapFileMaterial();					_md2.parseGeometry(_md2ByteArray);										if(_md2.materialURL=="")						continue;											if(_materials[_md2.materialURL])					{						// load from zip						BitmapFileMaterial(_md2.material).loadBytes(_materials[_md2.materialURL]);						Debug.trace(" ! Unzip :" + _entry.name);					}else{												// load from external						BitmapFileMaterial(_md2.material).load(_md2.materialURL);						Debug.trace(" ! Load :" + _md2.materialURL);					}				}			}						// gc			_materials = null;		}		private function onSuccess(event:ParserEvent):void		{			var model:MovieMesh = event.result as MovieMesh;			model.bothsides = bothsides;						_container.addChild(model);		}				/** @private */		arcane override function notifySuccess():void		{			if(autoPlay)				MovieMeshContainer3D(_container).play();			super.notifySuccess();		}				public var autoPlay:Boolean = true;				public var bothsides:Boolean = false;		/**		 * A scaling factor for all geometry in the model. Defaults to 1.		 */		public var scaling:Number = 1;		/**		 * Controls the automatic centering of geometry data in the model, improving culling and the accuracy of bounding dimension values.		 */		public var centerMeshes:Boolean;		/**		 * Creates a new <code>MDZ</code> object.		 */		public function MDZ()		{			_container = new MovieMeshContainer3D();			binary = true;		}				override public function destroy():void		{			if (_isDestroyed)				return;						_materials = null;						super.destroy();		}	}}