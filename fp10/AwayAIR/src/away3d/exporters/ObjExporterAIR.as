package away3d.exporters{	import flash.events.Event;	import flash.display.BitmapData;	import flash.utils.ByteArray;	import flash.filesystem.*;		import away3d.core.base.UV;	import away3d.core.base.Mesh;	import away3d.core.base.Geometry;	import away3d.core.base.Object3D;	import away3d.containers.ObjectContainer3D;	import away3d.core.base.Face;	import away3d.core.math.Number3D;	import away3d.arcane;	import away3d.animators.utils.PathUtils;	import away3d.materials.BitmapMaterial;		import away3d.exporters.data.JPEGEncoder;	import away3d.exporters.data.PNGEncoder; 	import away3d.exporters.data.ImageData;	import away3d.exporters.data.ExporterEventDispatcher;	 	use namespace arcane;		/**	* Class ObjExporterAIR generates and returns a string in the WaveFront obj format representing the object3D(s). optionally export the compagnon .mtl and images as well.	*/	public class ObjExporterAIR	{		private var objString:String;		private var mtlString:String;		private var _filename:String;		private var _matcount:int = 0;		private var _aMats:Array;		private var gcount:int = 0;		private var indV:int = 0;		private var indVn:int = 0;		private var indVt:int = 0;		private var indF:int = 0;		private var _scaling:Number;		private var _righthanded:Boolean;		private var _exportmtl:Boolean;		private var nRotation:Number3D = new Number3D();		private var exporterEventDispatcher:ExporterEventDispatcher;				private function addOnGenerateComplete(listener:Function):void        {			if(exporterEventDispatcher == null)				exporterEventDispatcher = new ExporterEventDispatcher();						exporterEventDispatcher.addOnGenerateComplete( listener);        }		 		private function removeOnGenerateComplete(listener:Function):void        {            exporterEventDispatcher.removeOnGenerateComplete(listener);        }			private  function write(object3d:Object3D):void		{			var aV:Array = [];			var aVn:Array = [];			var aVt:Array = [];			var aF:Array = [];					objString +="\n";						var aFaces:Array = (object3d as Mesh).faces;			var face:Face;			 			var n0:Number3D;			var n1:Number3D;			var n2:Number3D;			 			var geometry:Geometry = (object3d as Mesh).geometry;						var va:int;			var vb:int;			var vc:int;						var vta:int;			var vtb:int;			var vtc:int;						var na:int;			var nb:int;			var nc:int;						nRotation.x = object3d.rotationX;			nRotation.y = object3d.rotationY;			nRotation.z = object3d.rotationZ;			 			var nPos:Number3D = object3d.scenePosition;						var tmp:Number3D = new Number3D();			var j:int;			var aRef:Array = [vc, vb, va];						for(var i:int = 0; i<aFaces.length ; ++i)			{				face = aFaces[i];				for(j=2;j>-1;--j){					tmp.x =  (face["v"+j].x + nPos.x) *_scaling;					tmp.y =  (face["v"+j].y + nPos.y) *_scaling;					tmp.z =  (face["v"+j].z + nPos.z) *_scaling;					tmp = PathUtils.rotatePoint(tmp, nRotation);					if(_righthanded){						//will add Y up var						//tmp.y *= -1;						tmp.x *= -1;						 					}					aRef[j] = checkDoubles( aV, ("v "+tmp.x.toFixed(10)+" "+tmp.y.toFixed(10)+" "+tmp.z.toFixed(10)+"\n") );				}								vta = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv2.u : face.uv2.u)+" "+ face.uv2.v+"\n"));				vtb = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv1.u : face.uv1.u)+" "+ face.uv1.v+"\n"));				vtc = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv0.u : face.uv0.u)+" "+ face.uv0.v+"\n"));												/*vta = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv2.u : face.uv2.u)+" "+(_righthanded? 1-face.uv2.v : face.uv2.v)+"\n"));				vtb = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv1.u : face.uv1.u)+" "+(_righthanded? 1-face.uv1.v : face.uv1.v)+"\n"));				vtc = checkDoubles( aVt, ("vt "+(_righthanded? 1-face.uv0.u : face.uv0.u)+" "+(_righthanded? 1-face.uv0.v : face.uv0.v)+"\n"));				*/				n0 = geometry.getVertexNormal(face.v0);				n1 = geometry.getVertexNormal(face.v1);				n2 = geometry.getVertexNormal(face.v2);								na = checkDoubles( aVn, ("vn "+n2.x.toFixed(15)+" "+n2.y.toFixed(15)+" "+n2.z.toFixed(15)+"\n") );				nb = checkDoubles( aVn, ("vn "+n1.x.toFixed(15)+" "+n1.y.toFixed(15)+" "+n1.z.toFixed(15)+"\n") );			 	nc = checkDoubles( aVn, ("vn "+n0.x.toFixed(15)+" "+n0.y.toFixed(15)+" "+n0.z.toFixed(15)+"\n") );								aF.push("f "+(aRef[2]+indV)+"/"+(vta+indVt)+"/"+(na+indVn)+" "+(aRef[1]+indV)+"/"+(vtb+indVt)+"/"+(nb+indVn)+" "+(aRef[0]+indV)+"/"+(vtc+indVt)+"/"+(nc+indVn)+"\n");			}						indV += aV.length;			indVn += aVn.length;			indVt += aVt.length;			indF += aF.length;						objString += "# Number of vertices: "+aV.length+"\n";			for( i = 0; i < aV.length ; ++i){				objString += aV[i];			}						objString += "\n# Number of Normals: "+aVn.length+"\n";			for( i = 0; i < aVn.length ; ++i){				objString += aVn[i];			}						objString += "\n# Number of Texture Vertices: "+aVt.length+"\n";			for( i = 0; i < aVt.length ; ++i){				objString += aVt[i];			}						if(_exportmtl){				addToMtl(object3d as Mesh);			}							objString += "\n# Number of Polygons: "+aF.length+"\n";			for( i = 0; i < aF.length ; ++i){				objString += aF[i];			}					}				private function addToMtl(m:Mesh):void		{			if(m.material != null && m.material is BitmapMaterial){				var tmp:String;				var bmd:BitmapData = (m.material as BitmapMaterial).bitmap;				var extension:String = (bmd.transparent)? ".png" :".jpg";				var bmdname:String = m.name+extension;				//check on doubles				for(var i:int = 0;i<_aMats.length;++i){					if(_aMats[i].filename == bmdname){						objString +=  "usemtl awmat_"+i;						tmp = "newmtl awmat_"+i+"\n";						tmp+="Kd 1 1 1\nKa 0.2 0.2 0.2\nKs 0.2 0.2 0.2\nNs 128\nTr 1\nD 1\nmap_Kd images/"+bmdname+"\n\n";						mtlString+= tmp;						return;					}				}								objString +=  "usemtl awmat_"+_matcount;				tmp = "newmtl awmat_"+_matcount+"\n";				tmp+="Kd 1 1 1\nKa 0.2 0.2 0.2\nKs 0.2 0.2 0.2\nNs 128\nTr 1\nD 1\nmap_Kd images/"+bmdname+"\n\n";				_aMats.push(new ImageData(bmd, (bmd.transparent)? true : false, bmdname, 100));				mtlString+= tmp;				_matcount++;			}		}				private function checkDoubles(arr:Array, string:String):int		{			for(var i:int = 0;i<arr.length;++i){				if(arr[i] == string) return i+1;			}			arr.push(string);			return arr.length;		}				private  function parse(object3d:Object3D):void		{			if(object3d is ObjectContainer3D){							var obj:ObjectContainer3D = (object3d as ObjectContainer3D);				objString += "g g"+gcount+"\n";				gcount++;				for(var i:int =0;i<obj.children.length;i++){					if(obj.children[i] is ObjectContainer3D){						parse(obj.children[i]);					} else{						write( obj.children[i]);					}				}						} else {				write( object3d);			}		}				public function saveFiles(e:Event):void		{			removeOnGenerateComplete(saveFiles);			objString += "\n#\n# Total number of vertices: "+indV;			objString += "\n# Total number of Normals: "+indVn;			objString += "\n# Total number of Texture Vertices: "+indVt;			objString += "\n# Total number of Polygons: "+indF+"\n";			objString += "\n# End of File";						var aV:Array = [];			var aVn:Array = [];			var aVt:Array = [];			var aF:Array = [];			 			var f:File = File.documentsDirectory.resolvePath("/"+_filename);			f.addEventListener(Event.SELECT, writeFiles);			f.addEventListener(Event.CANCEL, dispatchCancelEvent);			f.browseForSave("Select directory to save your obj file");		}				private function checkPath(nativePath:String):String		{			var path:String = nativePath;			if(nativePath.indexOf(".obj") == -1){				path+=".obj";			}						return path;		}				private function writeFiles(e:Event):void		{			//recheck name in case user changed it again...			var filename:String = resolveFilename(File(e.target).name);			var myPattern:RegExp = new RegExp("NaN","g");			objString.replace(myPattern, "0");						myPattern = new RegExp("aw_mtl_holder","g");			if(_exportmtl && mtlString != ""){				objString = objString.replace(myPattern, "mtllib "+filename+".mtl");				} else{				objString = objString.replace(myPattern, "");				}						var file:File = File(e.target);			var stream:FileStream;						//obj file			var objfile:File = new File( file.nativePath+"/"+filename+".obj");			stream = new FileStream();			stream.open(objfile, FileMode.WRITE);			stream.writeUTFBytes(objString);			stream.close();			 			if(_exportmtl && mtlString != ""){				//mtl				var mtlfile:File = new File( file.nativePath+"/"+filename+".mtl");				stream = new FileStream();				stream.open(mtlfile, FileMode.WRITE);				stream.writeUTFBytes(mtlString);				stream.close();				//images				var byteArray:ByteArray;				var imagedata:ImageData;				var totalfiles:int = _aMats.length;				for(var i:int = 0;i<totalfiles;++i){						imagedata = _aMats[i];												if(imagedata.image != null){							if(imagedata.transparent){								byteArray = PNGEncoder.encode( imagedata.image );							} else {								var jpgEncoder:JPEGEncoder = new JPEGEncoder( imagedata.compress );								byteArray = jpgEncoder.encode( imagedata.image );							}														try{								var wr:File = new File( file.nativePath+"/images/"+imagedata.filename);								stream = new FileStream();								stream.open( wr , FileMode.WRITE);								stream.writeBytes ( byteArray, 0, byteArray.length );								stream.close();															} catch(e:Error){							}						}												if(exporterEventDispatcher != null){							var percent:Number =  ((i+1) / totalfiles) *100;							if(percent != 100)								dispatchSaveEvent(percent);						}										} 				 			} else {				cleanUp();				dispatchSaveEvent(100);			}					}				private function cleanUp():void		{			for(var i:int = 0;i<_aMats.length;++i){				_aMats[i] = null;			}			_aMats = null;		}				private function resolveFilename(filename:String):String		{			if(filename.indexOf(".") != -1)			 	filename = filename.substring(-1, filename.indexOf("."));						return filename;		}					/**		* Generates a string in the WaveFront obj format representing the object3D(s). Paste to a texteditor and save as filename.obj.		*/				function ObjExporterAIR( ):void		{		}		/**		* Triggers the generation of the obj file and optional mtl file. Once completed the user is prompted to select a directory to save the genrated files.		*		* @param	filename				String. The name of the obj file.		* @param	object3d				Object3D. The Object3D to be exported to WaveFront obj format.		* @param	exportmtl				Object3D. The Object3D to be exported to WaveFront obj format.		* @param	righthanded			[optional] Boolean. If the model output need to be flipped to righthanded system. Default = true.		* @param	scaling					[optional] Number. if the model output needs to be resized. Default = 0.001.		*/		public function export(filename:String, object3d:Object3D, exportmtl:Boolean= true, righthanded:Boolean = true, scaling:Number = 1):void        {			_filename = resolveFilename(filename);			_exportmtl = exportmtl;			_righthanded = righthanded;			_scaling = scaling;						objString = "# Obj file generated by Away3D: http://www.away3d.com ObjExporter AIR version 1.0 \n";			mtlString = "";						if(_exportmtl){				objString += "aw_mtl_holder\n";				_aMats = [];			}						addOnGenerateComplete(saveFiles);			parse(object3d);			 			dispatchGenerated();		}				public function get objFileString():String		{			return objString;		}				public function get mtlFileString():String		{			return mtlString;		}		 		/**		 * Default method for adding a savecomplete event listener		 * 		 * @param	listener		The listener function		 */		public function addOnSaveComplete(listener:Function):void        {			if(exporterEventDispatcher == null)				exporterEventDispatcher = new ExporterEventDispatcher();			exporterEventDispatcher.addOnSaveComplete( listener);        }				/**		 * Default method for removing a savecomplete event listener		 * 		 * @param	listener		The listener function		 */		public function removeOnSaveComplete(listener:Function):void        {            exporterEventDispatcher.removeOnSaveComplete(listener);        }				/**		 * Default method for adding a savecanceled event listener		 * 		 * @param	listener		The listener function		 */		public function addOnSaveCanceled(listener:Function):void        {			if(exporterEventDispatcher == null)				exporterEventDispatcher = new ExporterEventDispatcher();			exporterEventDispatcher.addOnSaveCanceled( listener );        }				/**		 * Default method for removing a savecanceled event listener		 * 		 * @param	listener		The listener function		 */		public function removeOnSaveCanceled(listener:Function):void        {            exporterEventDispatcher.removeOnSaveCanceled(listener);        }				//dispatches		private function dispatchGenerated():void		{			if(exporterEventDispatcher != null)				if(exporterEventDispatcher.hasGenerateListener)					exporterEventDispatcher.dispatchGenerated();		}				private function dispatchSaveEvent(percent:Number = 100):void		{			if(exporterEventDispatcher != null)				if(exporterEventDispatcher.hasSaveListener)					exporterEventDispatcher.dispatchSave(percent);		}				private function dispatchCancelEvent(e:Event):void		{			if(exporterEventDispatcher != null)				if(exporterEventDispatcher.hasCancelListener)					exporterEventDispatcher.dispatchCancel();		}		 		 	}}